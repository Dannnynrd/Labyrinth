// src/model/World.java
package model;

import java.util.ArrayList;
import java.util.Collections; // For shuffling
import java.util.Random;
import java.awt.Point;
import java.util.List;
import java.util.Stack; // For DFS
import view.View;

/**
 * The world is our model. It saves the bare minimum of information required to
 * accurately reflect the state of the game. Note how this does not know
 * anything about graphics.
 */
public class World {

	/** The world's width. */
	private int width;
	/** The world's height. */
	private int height;
	/** The player's x position in the world. */
	private int playerX = 0;
	/** The player's y position in the world. */
	private int playerY = 0;
	/** Walls. True if it's a wall, false if it's a path/floor. */
	private boolean[][] walls;
	/** Enemies */
	private final List<Point> enemies;
	/** Game over (True / False) */
	private boolean gameOver;

	private Difficulty difficulty;

	private boolean isPaused = false;

	private int currentLevel; // Field to track the current level
	private int playerHealth; // Player health

	/** End Block */
	private int endX = 0;
	private int endY = 0;

	// NEW: List to store active health power-up locations
	private final List<Point> healthPowerups;
	private static final int INITIAL_HEALTH_POWERUPS = 3; // Number of health power-ups to spawn per level

	/** Set of views registered to be notified of world updates. */
	private final ArrayList<View> views = new ArrayList<>();

	/**
	 * Creates a new world with the given size.
	 * @param difficulty The initial difficulty setting for the world.
	 */
	public World(Difficulty difficulty) {
		this.difficulty = difficulty;
		this.enemies = new ArrayList<>();
		this.healthPowerups = new ArrayList<>(); // Initialize power-ups list
		this.currentLevel = 1; // Initialize level to 1
		this.playerHealth = 3; // Initialize player health

		restart(difficulty, true); // Call restart with initial difficulty, resetting health
	}

	/**
	 * Resets and restarts the game with a new difficulty or the current difficulty.
	 * This method initializes the maze, player, end, and enemy positions.
	 * @param newDifficulty The difficulty setting for the new game.
	 * @param resetPlayerHealth True if player health should be reset to default, false to keep current health.
	 */
	public void restart(Difficulty newDifficulty, boolean resetPlayerHealth) {
		this.difficulty = newDifficulty; // Update the world's difficulty
		// Reset game over status
		this.gameOver = false;
		// Reset paused status
		this.isPaused = false;
		if (resetPlayerHealth) { // Only reset health if explicitly requested
			this.playerHealth = 3; // Reset player health on restart
		}


		// Use scaled dimensions based on current level.
		// Ensure dimensions are odd for maze generation, as common algorithms prefer it for grid consistency (path at odd, walls at even or vice versa).
		this.width = difficulty.getScaledWorldSize(currentLevel);
		this.height = difficulty.getScaledWorldSize(currentLevel);
		if (this.width % 2 == 0) this.width++; // Make it odd
		if (this.height % 2 == 0) this.height++; // Make it odd


		this.walls = new boolean[width][height]; // Initialize the walls array here

		this.enemies.clear();
		this.healthPowerups.clear(); // Clear power-ups on restart

		// Initialize all cells as walls for maze generation
		for (int i = 0; i < height; i++) {
			for (int j = 0; j < width; j++) {
				this.walls[j][i] = true; // All are walls initially
			}
		}

		Random rand = new Random();

		// Set player and end positions.
		// Player and end should be placed on 'path' cells generated by DFS (typically odd coordinates if maze starts at 1,1).
		// We'll place them at arbitrary valid odd coordinates.
		this.playerX = rand.nextInt((width - 1) / 2) * 2 + 1;
		this.playerY = rand.nextInt((height - 1) / 2) * 2 + 1;

		do {
			this.endX = rand.nextInt((width - 1) / 2) * 2 + 1;
			this.endY = rand.nextInt((height - 1) / 2) * 2 + 1;
		} while (this.endX == this.playerX && this.endY == this.playerY);

		// Generate the maze using Depth-First Search (Recursive Backtracker)
		generateMazeDFS(playerX, playerY); // Start DFS from player's position

		// Post-processing: Remove a percentage of walls to make the labyrinth more open
		removeRandomWalls(difficulty.getScaledWallPercentage(currentLevel));


		// Ensure player and end positions are not walls (they should be after DFS, but as a safeguard)
		walls[playerX][playerY] = false;
		walls[endX][endY] = false;


		// Place enemies
		int numberOfEnemies = (int) (width * height * difficulty.getScaledEnemyPercentage(currentLevel));
		for (int i = 0; i < numberOfEnemies; i++) {
			int enemyX, enemyY;
			boolean isWall, isPlayer, isEnd, isPowerup;
			do {
				enemyX = rand.nextInt(width);
				enemyY = rand.nextInt(height);
				isWall = isWall(enemyX, enemyY);
				isPlayer = (enemyX == this.playerX && enemyY == this.playerY);
				isEnd = (enemyX == this.endX && enemyY == this.endY);
				isPowerup = isPowerupAt(enemyX, enemyY); // Check against powerup locations
			} while (isWall || isPlayer || isEnd || isPowerup); // Ensure enemy is not on a wall, player, end, or powerup
			enemies.add(new Point(enemyX, enemyY));
		}

		// Place health power-ups
		for (int i = 0; i < INITIAL_HEALTH_POWERUPS; i++) {
			int powerupX, powerupY;
			boolean isWall, isPlayer, isEnd, isEnemy, isPowerup;
			do {
				powerupX = rand.nextInt(width);
				powerupY = rand.nextInt(height);
				isWall = isWall(powerupX, powerupY);
				isPlayer = (powerupX == this.playerX && powerupY == this.playerY);
				isEnd = (powerupX == this.endX && powerupY == this.endY);
				isEnemy = isEnemyAt(powerupX, powerupY);
				isPowerup = isPowerupAt(powerupX, powerupY); // Check against other powerup locations
			} while (isWall || isPlayer || isEnd || isEnemy || isPowerup); // Ensure powerup is not on a wall, player, end, enemy, or another powerup
			healthPowerups.add(new Point(powerupX, powerupY));
		}

		// Checks if player starts on an enemy
		// Instead of game over, lose health
		for (Point enemy : enemies) {
			if (enemy.x == playerX && enemy.y == playerY) {
				playerHealth--;
				if (playerHealth <= 0) {
					this.gameOver = true; // Player starts on an enemy and has no health left, game over
				}
				break;
			}
		}

		updateViews();
	}

	/**
	 * Generates a maze using the Depth-First Search (Recursive Backtracker) algorithm.
	 * Carves paths by setting wall cells to false.
	 *
	 * @param startX The starting X coordinate for maze generation.
	 * @param startY The starting Y coordinate for maze generation.
	 */
	private void generateMazeDFS(int startX, int startY) {
		Stack<Point> stack = new Stack<>();
		boolean[][] visited = new boolean[width][height];
		Random rand = new Random();

		stack.push(new Point(startX, startY));
		visited[startX][startY] = true;
		walls[startX][startY] = false; // Carve out the starting cell

		while (!stack.isEmpty()) {
			Point current = stack.peek(); // Don't pop yet, need to check neighbors

			List<Direction> unvisitedNeighbors = getUnvisitedNeighbors(current.x, current.y, visited);

			if (!unvisitedNeighbors.isEmpty()) {
				Direction chosenDirection = unvisitedNeighbors.get(rand.nextInt(unvisitedNeighbors.size()));
				int nextX = current.x + chosenDirection.deltaX * 2; // Move two steps to get to a new cell
				int nextY = current.y + chosenDirection.deltaY * 2;

				// Carve out the wall between current and next cell
				walls[current.x + chosenDirection.deltaX][current.y + chosenDirection.deltaY] = false;
				walls[nextX][nextY] = false; // Carve out the next cell

				visited[nextX][nextY] = true;
				stack.push(new Point(nextX, nextY));
			} else {
				stack.pop(); // Backtrack
			}
		}
	}

	/**
	 * Gets a list of unvisited neighbors (cells two steps away) from the given coordinates.
	 * This is used by the DFS maze generation to find new cells to carve paths to.
	 *
	 * @param x The current X coordinate.
	 * @param y The current Y coordinate.
	 * @param visited A 2D array indicating visited cells.
	 * @return A list of Directions to unvisited neighbors.
	 */
	private List<Direction> getUnvisitedNeighbors(int x, int y, boolean[][] visited) {
		List<Direction> neighbors = new ArrayList<>();
		// Check all four cardinal directions (moving 2 steps at a time for maze carving)
		Direction[] cardinalDirections = {Direction.UP, Direction.DOWN, Direction.LEFT, Direction.RIGHT};

		for (Direction dir : cardinalDirections) {
			int neighborX = x + dir.deltaX * 2;
			int neighborY = y + dir.deltaY * 2;

			// Check bounds and if the neighbor is unvisited
			if (neighborX >= 0 && neighborX < width && neighborY >= 0 && neighborY < height && !visited[neighborX][neighborY]) {
				neighbors.add(dir);
			}
		}
		Collections.shuffle(neighbors); // Shuffle to make maze generation less predictable
		return neighbors;
	}

	/**
	 * Removes a percentage of the existing walls to make the labyrinth more open.
	 * Walls that are essential for the labyrinth's structure (border, player/end surroundings)
	 * are preserved.
	 *
	 * @param percentageToOpen The percentage of existing walls to potentially remove (0.0 to 1.0).
	 * A higher value means more open space.
	 */
	private void removeRandomWalls(double percentageToOpen) {
		Random rand = new Random();
		int totalWalls = 0;
		List<Point> potentialWallsToRemove = new ArrayList<>();

		// Identify all existing walls that are not player/end and can potentially be removed
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < width; x++) {
				if (walls[x][y] && !(x == playerX && y == playerY) && !(x == endX && y == endY)) {
					potentialWallsToRemove.add(new Point(x, y));
					totalWalls++;
				}
			}
		}

		// Calculate how many walls to actually remove based on the percentage
		int wallsToRemoveCount = (int) (potentialWallsToRemove.size() * percentageToOpen);

		// Shuffle the list of potential walls and remove the first 'wallsToRemoveCount' walls
		Collections.shuffle(potentialWallsToRemove, rand);

		for (int i = 0; i < wallsToRemoveCount && i < potentialWallsToRemove.size(); i++) {
			Point wall = potentialWallsToRemove.get(i);
			// Only remove if it's still a wall and not player/end (double check)
			if (walls[wall.x][wall.y] && !(wall.x == playerX && wall.y == playerY) && !(wall.x == endX && wall.y == endY)) {
				walls[wall.x][wall.y] = false; // Remove the wall
			}
		}
	}


	///////////////////////////////////////////////////////////////////////////
	// Getters and Setters
	public boolean isPaused() {
		return isPaused;
	}
	public void setPaused(boolean paused) {
		isPaused = paused;
		updateViews();
	}
	/**
	 * Returns the width of the world.
	 *
	 * @return the width of the world.
	 */
	public int getWidth() {
		return width;
	}

	/**
	 * Returns the height of the world.
	 *
	 * @return the height of the world.
	 */
	public int getHeight() {
		return height;
	}

	/**
	 * Returns the player's x position.
	 *
	 * @return the player's x position.
	 */
	public int getPlayerX() {
		return playerX;
	}

	/**
	 * Sets the player's x position.
	 *
	 * @param playerX the player's x position.
	 */
	public void setPlayerX(int playerX) {
		playerX = Math.max(0, playerX);
		playerX = Math.min(getWidth() - 1, playerX);
		this.playerX = playerX;
	}

	/**
	 * Returns the player's y position.
	 *
	 * @return the player's y position.
	 */
	public int getPlayerY() {
		return playerY;
	}

	/**
	 * Sets the player's y position.
	 *
	 * @param playerY the player's y position.
	 */
	public void setPlayerY(int playerY) {
		playerY = Math.max(0, playerY);
		playerY = Math.min(getHeight() - 1, playerY);
		this.playerY = playerY;
	}

	public int getEndX() {
		return endX;
	}
	public int getEndY() {
		return endY;
	}

	public List<Point> getEnemies() {
		return enemies;
	}

	// Getter for health power-ups
	public List<Point> getHealthPowerups() {
		return healthPowerups;
	}

	public boolean isGameOver() {return gameOver;}

	// Getter for player health
	public int getPlayerHealth() {
		return playerHealth;
	}

	public boolean isEnemyAt(int x, int y) {
		for (Point enemy : enemies) {
			if(enemy.x == x && enemy.y == y){
				return true;
			}
		}
		return false;
	}

	// Check if a powerup is at the given coordinates
	public boolean isPowerupAt(int x, int y) {
		for (Point powerup : healthPowerups) {
			if(powerup.x == x && powerup.y == y){
				return true;
			}
		}
		return false;
	}

	// Getter for current level
	public int getCurrentLevel() {
		return currentLevel;
	}

	public long getEnemyMoveIntervalMillis() {
		return difficulty.getScaledEnemyMoveIntervalMillis(currentLevel);
	}

	// Getter for current difficulty
	public Difficulty getDifficulty() {
		return difficulty;
	}
	public void setCurrentLevel(int currentLevel) {
		this.currentLevel = currentLevel;
	}
	///////////////////////////////////////////////////////////////////////////
	// Player Management

	/**
	 * Moves the player along the given direction.
	 *
	 * @param direction where to move.
	 */

	public void movePlayer(Direction direction) {
		if (isGameOver() || isPaused()) {
			return;
		}
		int newPlayerX = getPlayerX() + direction.deltaX;
		int newPlayerY = getPlayerY() + direction.deltaY;

		if (!isWall(newPlayerX, newPlayerY)) {
			setPlayerX(newPlayerX);
			setPlayerY(newPlayerY);

			// Check if player collected a power-up
			Point collectedPowerup = null;
			for (Point powerup : healthPowerups) {
				if (playerX == powerup.x && playerY == powerup.y) {
					playerHealth = Math.min(playerHealth + 1, 5); // Increase health, cap at 5 for example
					collectedPowerup = powerup;
					break;
				}
			}
			if (collectedPowerup != null) {
				healthPowerups.remove(collectedPowerup);
			}

			// Check if player reached the end point
			if (playerX == endX && playerY == endY) {
				currentLevel++; // Increment level
				restart(this.difficulty, false); // Restart the level with current difficulty settings, DO NOT reset health
				return; // Exit method, a new level has started
			}

			// If player encounters an enemy, lose health instead of immediate game over
			if(isEnemyAt(getPlayerX(),getPlayerY())){
				playerHealth--;
				if (playerHealth <= 0) {
					this.gameOver = true;
				}
			}
		}
		updateViews(); // Update views after player move
	}

	/**
	 * Moves all enemies towards the player, avoiding walls if possible.
	 */
	public void moveEnemies() {
		if (isPaused() || isGameOver()) {
			return;
		}

		Random rand = new Random();

		for (Point enemy : enemies) {
			int currentEnemyX = enemy.x;
			int currentEnemyY = enemy.y;

			int targetX = playerX;
			int targetY = playerY;

			int deltaX = Integer.compare(targetX, currentEnemyX);
			int deltaY = Integer.compare(targetY, currentEnemyY);

			// Try to move in one direction, or randomly choose
			if (deltaX != 0 && deltaY != 0) {
				if (rand.nextBoolean()) { // Try to move horizontally
					int potentialNewX = currentEnemyX + deltaX;
					if (!isWall(potentialNewX, currentEnemyY)) {
						enemy.setLocation(potentialNewX, currentEnemyY);
					} else { // If horizontal is blocked, try vertically
						int potentialNewY = currentEnemyY + deltaY;
						if (!isWall(currentEnemyX, potentialNewY)) {
							enemy.setLocation(currentEnemyX, potentialNewY);
						}
					}
				} else { // Try to move vertically
					int potentialNewY = currentEnemyY + deltaY;
					if (!isWall(currentEnemyX, potentialNewY)) {
						enemy.setLocation(currentEnemyX, potentialNewY);
					} else { // If vertical is blocked, try horizontally
						int potentialNewX = currentEnemyX + deltaX;
						if (!isWall(potentialNewX, currentEnemyY)) {
							enemy.setLocation(potentialNewX, currentEnemyY);
						}
					}
				}
			} else if (deltaX != 0) { // Only horizontal movement needed
				int potentialNewX = currentEnemyX + deltaX;
				if (!isWall(potentialNewX, currentEnemyY)) {
					enemy.setLocation(potentialNewX, currentEnemyY);
				}
			} else if (deltaY != 0) { // Only vertical movement needed
				int potentialNewY = currentEnemyY + deltaY;
				if (!isWall(currentEnemyX, potentialNewY)) {
					enemy.setLocation(currentEnemyX, potentialNewY);
				}
			}

			// Collision check after enemy moves - lose health instead of game over
			if (enemy.x == playerX && enemy.y == playerY) {
				playerHealth--;
				if (playerHealth <= 0) {
					this.gameOver = true;
				}
				break; // Game is over or health lost, no need to move other enemies
			}
		}
		updateViews(); // Update views after all enemies moved
	}


	///////////////////////////////////////////////////////////////////////////
	// View Management

	/**
	 * Adds the given view of the world and updates it once. Once registered through
	 * this method, the view will receive updates whenever the world changes.
	 *
	 * @param view the view to be registered.
	 */
	public void registerView(View view) {
		views.add(view);
		view.update(this);
	}

	/**
	 * Updates all views by calling their {@link View#update(World)} methods.
	 */
	private void updateViews() {
		for (int i = 0; i < views.size(); i++) {
			views.get(i).update(this);
		}
	}

	/**
	 * Checks if a given coordinate represents a wall.
	 *
	 * @param x The X coordinate to check.
	 * @param y The Y coordinate to check.
	 * @return True if the coordinate is a wall or out of bounds, false otherwise.
	 */
	public boolean isWall(int x, int y) {
		if  (x >= 0 && x < width && y >= 0 && y < height) {
			return walls[x][y];
		}
		return true; // Treat out-of-bounds as walls
	}

	/**
	 * Returns the direction to the end point relative to the player.
	 * @return A string indicating the direction (e.g., "North", "South-East", or "Here").
	 */
	public String getDirectionToEnd() {
		int deltaX = endX - playerX;
		int deltaY = endY - playerY;

		if (deltaX == 0 && deltaY == 0) {
			return "Here";
		}

		StringBuilder direction = new StringBuilder();

		if (deltaY < 0) {
			direction.append("North");
		} else if (deltaY > 0) {
			direction.append("South");
		}

		if (deltaX < 0) {
			direction.append("West");
		} else if (deltaX > 0) {
			direction.append("East");
		}

		return direction.toString();
	}
}